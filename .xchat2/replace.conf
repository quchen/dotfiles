NAME !==
CMD ≠

NAME (c)
CMD ©

NAME +-
CMD ±

NAME -->
CMD →

NAME ...
CMD …

NAME :-P
CMD :-þ

NAME :::
CMD ∷

NAME :P
CMD :þ

NAME <--
CMD ←

NAME <3
CMD ♥

NAME <==
CMD ≤

NAME <==>
CMD ⇔

NAME ==>
CMD ⇒

NAME Arxiv
CMD Arχiv

NAME O_O
CMD ಠ_ಠ

NAME \!?
CMD ‽

NAME \*
CMD ★

NAME \Delta
CMD Δ

NAME \Gamma
CMD Γ

NAME \Lambda
CMD Λ

NAME \N
CMD ℕ

NAME \Omega
CMD Ω

NAME \Phi
CMD Φ

NAME \Pi
CMD Π

NAME \Psi
CMD Ψ

NAME \Q
CMD ℚ

NAME \R
CMD ℝ

NAME \Sigma
CMD Σ

NAME \Theta
CMD Θ

NAME \Xi
CMD Ξ

NAME \Z
CMD ℤ 

NAME \alpha
CMD α

NAME \angry
CMD ლ(ಠ益ಠლ)

NAME \approx
CMD ≈

NAME \aat
CMD asAppliedTo = const :: (a -> b) -> a -> (a -> b)

NAME \automaton
CMD You need category theory to write Haskell the same way you need automaton theory to write C.

NAME \beta
CMD β

NAME \bot
CMD ⊥

NAME \cdot
CMD ·

NAME \chi
CMD χ

NAME \circ
CMD ∘

NAME \cong
CMD ≅

NAME \delta
CMD δ

NAME \epsilon
CMD ε

NAME \equiv
CMD ≡

NAME \error
CMD What is the source code? What do you want to do? What have you tried? What did your attempts amount to? What do you think was wrong?

NAME \eta
CMD η

NAME \exists
CMD ∃

NAME \forall
CMD ∀

NAME \gamma
CMD γ

NAME \geq
CMD ≥

NAME \happy
CMD ヽ (＾▽＾) ﾉ

NAME \in
CMD ∈

NAME \infty
CMD ∞

NAME \iota
CMD ι

NAME \kappa
CMD κ

NAME \lambda
CMD λ

NAME \latex
CMD LaTeχ

NAME \mu
CMD μ

NAME \neq
CMD ≠

NAME \ni
CMD ∋

NAME \not
CMD ¬

NAME \nu
CMD ν

NAME \omega
CMD ω

NAME \phi
CMD φ

NAME \pi
CMD π

NAME \private
CMD You can also message lambdabot in private (/msg lambdabot) when you just want to try things out (as opposed to demonstrating code to others).

NAME \psi
CMD ψ

NAME \quchen
CMD ˈkuːχn̩

NAME \rho
CMD ρ

NAME \rightarrow
CMD →

NAME \sassy
CMD ( ͡° ͜ʖ ͡°)

NAME \sigma
CMD σ

NAME \skull
CMD ☠

NAME \snowman
CMD ☃

NAME \src
CMD Lambdabot @src database: https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source

NAME \star
CMD ★

NAME \tau
CMD τ

NAME \theta
CMD ϑ

NAME \times
CMD ×

NAME \upsilon
CMD υ

NAME \vdash
CMD ⊢

NAME \vee
CMD ∨

NAME \wedge
CMD ∧

NAME \xi
CMD ξ

NAME \yeah
CMD (•_•)     ( •_•)>⌐■-■     (⌐■_■)     YEEEEEAAAAAAAHHHHH

NAME \zeta
CMD ζ

NAME ^TM
CMD ™

NAME ^tm
CMD ™

NAME adn
CMD and

NAME arxiv
CMD Arχiv

NAME teh
CMD the

NAME \soviet
CMD ☭

NAME \subseteq
CMD ⊆

NAME \supseteq
CMD ⊇

NAME \subset
CMD ⊂

NAME \supset
CMD ⊃

NAME \subsetneq
CMD ⊊

NAME \supsetneq
CMD ⊋

NAME \reader
CMD ⊥ >>= return = \r -> return (⊥ r) r = \r -> const (⊥ r) r = const ⊥ ≠ ⊥

NAME \beakywarning
CMD Just a warning, beaky is the archetypical help vampire. He comes by every couple of weeks asking random questions with lots of buzzwords and tricks new people into wasting their time with him. He has been doing this for over two years now.

NAME \upset
CMD (╯°□°）╯

NAME \djinn_cont
CMD ?djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r

NAME \foldl
CMD foldl f z xs  =  foldr (\y ys acc -> ys (f acc y)) id xs z

NAME \ask
CMD ?where justask

NAME \acker
CMD :t let a x=(x,x);b=a.a;c=b.b in c()

NAME \zz
CMD ↯

NAME \fmonoid
CMD > sortBy (comparing length <> compare) ["hello", "a", "bc", "world", "asdfg"]

NAME \varnothing
CMD ∅

NAME \not\elem
CMD ∉

NAME \sqsubseteq
CMD ⊑

NAME \sqsupseteq
CMD ⊒

NAME \sqsubset
CMD ⊏

NAME \sqsupset
CMD ⊐

NAME \dance
CMD ᕕ( ᐛ )ᕗ

