NAME \neq
CMD ≠

NAME (c)
CMD ©

NAME +-
CMD ±

NAME ...
CMD …

NAME :-P
CMD :-þ

NAME :P
CMD :þ

NAME <3
CMD ♥

NAME Arxiv
CMD Arχiv

NAME O_O
CMD ಠ_ಠ

NAME \!?
CMD ‽

NAME \*
CMD ★

NAME \Delta
CMD Δ

NAME \Gamma
CMD Γ

NAME \Lambda
CMD Λ

NAME \N
CMD ℕ

NAME \Omega
CMD Ω

NAME \Phi
CMD Φ

NAME \Pi
CMD Π

NAME \Psi
CMD Ψ

NAME \Q
CMD ℚ

NAME \R
CMD ℝ

NAME \Sigma
CMD Σ

NAME \Theta
CMD Θ

NAME \Xi
CMD Ξ

NAME \Z
CMD ℤ 

NAME \aat
CMD asAppliedTo = const :: (a -> b) -> a -> (a -> b)

NAME \acker
CMD :t let a x=(x,x);b=a.a;c=b.b in c()

NAME \alpha
CMD α

NAME \angry
CMD ლ(ಠ益ಠლ)

NAME \approx
CMD ≈

NAME \ask
CMD ?where justask

NAME \automaton
CMD You need category theory to write Haskell the same way you need automaton theory to write C.

NAME \beakywarning
CMD Just a warning, beaky is the archetypical help vampire. He comes by every couple of weeks asking random questions with lots of buzzwords and tricks new people into wasting their time with him. He has been doing this for over two years now.

NAME \beta
CMD β

NAME \bot
CMD ⊥

NAME \cdot
CMD ·

NAME \chi
CMD χ

NAME \circ
CMD ∘

NAME \cong
CMD ≅

NAME \dance
CMD ᕕ( ᐛ )ᕗ

NAME \delta
CMD δ

NAME \djinn_cont
CMD ?djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r

NAME \epsilon
CMD ε

NAME \equiv
CMD ≡

NAME \error
CMD What is the source code? What do you want to do? What have you tried? What did your attempts amount to? What do you think was wrong?

NAME \eta
CMD η

NAME \exists
CMD ∃

NAME \fmonoid
CMD > sortBy (comparing length <> compare) ["hello", "a", "bc", "world", "asdfg"]

NAME \foldl
CMD foldl f z xs  =  foldr (\y ys acc -> ys (f acc y)) id xs z

NAME \forall
CMD ∀

NAME \gamma
CMD γ

NAME \geq
CMD ≥

NAME \happy
CMD ヽ (＾▽＾) ﾉ

NAME \in
CMD ∈

NAME \infty
CMD ∞

NAME \iota
CMD ι

NAME \kappa
CMD κ

NAME \lambda
CMD λ

NAME \latex
CMD LaTeχ

NAME \mu
CMD μ

NAME \neq
CMD ≠

NAME \ni
CMD ∋

NAME \not
CMD ¬

NAME \not\elem
CMD ∉

NAME \nu
CMD ν

NAME \omega
CMD ω

NAME \oplus
CMD ⨁

NAME \otimes
CMD ⨂

NAME \phi
CMD φ

NAME \pi
CMD π

NAME \private
CMD You can also message lambdabot in private (/msg lambdabot) when you just want to try things out (as opposed to demonstrating code to others).

NAME \psi
CMD ψ

NAME \quchen
CMD ˈkuːχn̩

NAME \reader
CMD ⊥ >>= return  =  \r -> return (⊥ r) r  =  \r -> const (⊥ r) r  =  \r -> ⊥ r  =  \_ -> ⊥  ≠  ⊥

NAME \rho
CMD ρ

NAME \rightarrow
CMD →

NAME \sassy
CMD ( ͡° ͜ʖ ͡°)

NAME \sigma
CMD σ

NAME \skull
CMD ☠

NAME \snowman
CMD ☃

NAME \soviet
CMD ☭

NAME \sqsubset
CMD ⊏

NAME \sqsubseteq
CMD ⊑

NAME \sqsupset
CMD ⊐

NAME \sqsupseteq
CMD ⊒

NAME \src
CMD Lambdabot @src database: https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source

NAME \star
CMD ★

NAME \subset
CMD ⊂

NAME \subseteq
CMD ⊆

NAME \subsetneq
CMD ⊊

NAME \supset
CMD ⊃

NAME \supseteq
CMD ⊇

NAME \supsetneq
CMD ⊋

NAME \tau
CMD τ

NAME \theta
CMD ϑ

NAME \times
CMD ×

NAME \upset
CMD (╯°□°）╯

NAME \upsilon
CMD υ

NAME \varnothing
CMD ∅

NAME \vdash
CMD ⊢

NAME \vee
CMD ∨

NAME \wedge
CMD ∧

NAME \xi
CMD ξ

NAME \yeah
CMD (•_•)     ( •_•)>⌐■-■     (⌐■_■)     YEEEEEAAAAAAAHHHHH

NAME \zeta
CMD ζ

NAME \zz
CMD ↯

NAME ^TM
CMD ™

NAME ^tm
CMD ™

NAME adn
CMD and

NAME arxiv
CMD Arχiv

NAME teh
CMD the

NAME \foldr
CMD \f z xs -> foldr (\x rest acc -> rest (f acc x)) id xs z

